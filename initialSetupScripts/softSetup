#!/usr/bin/python
###############################################################
## setup.py
## Author: Todd Sukolsky
## Copyright of Todd Sukolsky and Re.Cycle
## Date Created: 2/9/2013
## Last Revised: 2/9/2013
###############################################################
## Description:
##    This module is responisble for setting the Watchdog AVR's
## time in the case that there is a valid time stamp from the 
## NMEA strings of the GPS. Date is not preserved and must be
## user provided in the case of a complete system halt. This
## module will establish a connection, send the string that is
## stored in a remote file to the watchdog avr. It will then exit.
##
###############################################################
## Changes to be made:
##     Probably going to add an outer loop for the send function;
## Every 30 seconds, if no time is set, loop through the function
## looking for valid GPS strings. Once one is good, then proceed.
## This will mean we can integrate initTime.py with setup.py
##
###############################################################

import sys
import os
import serial


#Initializations for the serial port
serialPort='/dev/ttyO2'
baudRate=9600

#Declare file i/o variables
#logFile='/tmp/logs/startupLog.txt'
#savedTimeFile='/tmp/nmea/savedTimeFile.txt'
logFile='/home/todd/Documents/BoneDev/customFiles/startupLog.txt'		#what we are going to print to for log
savedTimeFile='/home/todd/Documents/BoneDev/customFiles/NMEA/initTime.txt'	#where the time is that we are looking for.
inputTime=open(savedTimeFile,'r')
outputSuccess.open(logFile,'a')


#This file should have only one line
firstTime=inputTime.readline()
firstTime.strip('\n').strip(' ')

## Set port functions, then open
serPort = serial.Serial(
        port=serialPort,
        baudrate=baudRate,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        bytesize=serial.EIGHTBITS
)
try:
	serPort.open()
except:
	print "Error opening port" + serialPort
	exit()

### MAIN FUNCTIONALITY HERE ###
#initialize boolean values. Will keep trying until ACK is acheived
connectionSet=False
success=False
while success=False:
	if connectionSet=False:
		connectionSet=setupConnection()
	if connectionSet=True and success=False:
		success=sendTime()
		if success=False:
			connectionSet=False


#Write to a log that I am done
outputSuccess.write("init_time...DONE\n")
exit()

##############################################################
############### 	Functions 	######################
##############################################################

#### Setup Connection Routine ####
def setupConnection():
	#Setup communication line with board, Alert the Watchdog we are about to ask for something
	sendInterrupt()
	#Get ACK
	settingUp=True
	start=time.time()
	while settingUp:
		if (time.time()-start)<2:		#Sets timeout to 2 seconds, less than half of actual timeout on AVR
			ack=getString(100.0/1000.0)		#checks every 100ms
			if (ack=="ACKT"):
				return True
				settingUp=False		#unneeded, just for protection
		else:					#Took to long, chip might be talking to graphics avr, shouldnt be though...wait for timeout to occur then retry
			time.sleep(6)				#Timeout on AVR is 5 seconds
			sendInterrupt()				#send interrupt, reset start for new timeout
			start=time.time()

#### Send Time Routine ####
def sendTime():	
	#Got ack, time to send time string good or bad
	communicating=True
	oString= global firstTime
	sendString(oString)
	start=time.time()
	while communicating:
		if (time.time()-start)<4:		#longer timeout, only 2 from first + 4 now is full 
			ack=getString(100.0/1000.0) 		#check every 100ms	
			if (ack=="ACK"+oString):
				return True
		else:		#we probably just had a timeout, setup the connection again
			return False	

#### Send Interrupt Routine ####
def sendInterrupt():
	os.system("echo \"high\" > /sys/class/gpio/gpio38/direction")
	os.system("echo \"low\" > /sys/class/gpio/gpio38/direction")

#### Send String Routine ####
def sendString(STRING):
	for char in STRING:
		serPort.write(char)
		time.sleep(10.0/1000.0)
	
#### Get String Routine ####
def getString(waitTime)
	time.sleep(waitTime)
	return serPort.read(serPort.inWaiting())






















		

exit()
